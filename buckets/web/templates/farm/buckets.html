{% extends 'farm/base.html' %}

{% block content %}

<h1>Buckets</h1>

<script type="text/babel">
var target_el = thisNext();

var Store = {};
Store.buckets = {{ buckets|json|safe }};
Store.rerender = function() {
  ReactDOM.render(<BucketTable buckets={Store.buckets}/>, target_el);
}
Store.updateBucket = function(bucket) {
  _.each(Store.buckets, function(old_bucket) {
    if (old_bucket.id === bucket.id) {
      _.merge(old_bucket, bucket);
    }
  });
  Store.rerender();
}


var BucketRow = React.createClass({
  getInitialState: function() {
    return {
      pending_amount: '',
      underDrag: false,
      isDragging: false,
    }
  },
  refreshBucket: function() {
    this.props.onBucketDirty(this.props.bucket);
  },
  pendingKeyUp: function(e) {
    if (e.keyCode === 13) {
      this.doTransaction();
    }
  },
  pendingChanged: function(value) {
    this.setPending(value);
  },
  setPending: function(value) {
    this.setState({
      pending_amount: value
    })
    this.props.onPendingChange(this.props.bucket, value);
  },
  doTransaction: function() {
    var amount = this.state.pending_amount;
    this.setPending('');
    apiRequest({
      method: 'bucket_transact',
      kwargs: {
        bucket_id: this.props.bucket.id,
        amount: amount,
      }
    }, function(response) {
      this.refreshBucket();
    }.bind(this));
  },
  dragStart: function(ev) {
    if (handle.contains(this.state.target)) {
      console.log('contains');
    }
    ev.dataTransfer.setData('bucket', this.props.bucket.id)
    this.setState({isDragging: true});
  },
  dragEnd: function(ev) {
    this.setState({isDragging: false});
  },
  drop: function(ev) {
    this.setState({underDrag: false});
    ev.preventDefault();
    console.log('drop', this.props.bucket.name, ev);
    var data = ev.dataTransfer.getData('bucket');
    console.log('drop data', data);
  },
  dragOver: function(ev) {
    console.log('dragOver', this.props.bucket.name);
    ev.preventDefault();
    var data = ev.dataTransfer.getData('bucket');
    this.setState({underDrag: true});
  },
  dragLeave: function(ev) {
    console.log('leave', this.props.bucket.name);
    ev.preventDefault();
    this.setState({underDrag: false});
  },
  onHandleMouseDown: function(ev) {
    console.log('mousedown', ev.target);
  },
  render: function() {
    var goal_bar;
    var class_name = '';
    if (this.state.isDragging) {
      class_name += ' dragging';
    }
    if (this.state.underDrag) {
      class_name += ' underdrag';
    }
    if (this.props.bucket.kind === 'goal') {
      goal_bar = (<GoalBar max={this.props.bucket.goal} value={this.props.bucket.balance} />);
    }
    return (
      <tr className={class_name} draggable="true" onDragStart={this.dragStart} onDragEnd={this.dragEnd} onDragOver={this.dragOver} onDrop={this.drop} onDragLeave={this.dragLeave}>
        <td className="handle" onMouseDown={this.onHandleMouseDown}>H</td>
        <td>{this.props.bucket.name}</td>
        <td className="right"><Money value={this.props.bucket.balance} /></td>
        <td className="right">
          <MoneyInput className="right"
            value={this.state.pending_amount}
            onKeyUp={this.pendingKeyUp}
            onChange={this.pendingChanged}
            size="10" />
        </td>
        <td className="right"><Money value={this.props.bucket.deposit} /></td>
        <td>{goal_bar}</td>
        <td><a href={'buckets/'+this.props.bucket.id}>Edit</a></td>
      </tr>
    )
  }
});



var BucketTable = React.createClass({
  getInitialState: function() {
    return {
      pendings: {}
    }
  },
  pendingChanged: function(bucket, pending) {
    this.state.pendings[bucket.id] = pending;
    this.setState(this.state);
  },
  bucketIsDirty: function(bucket) {
    apiRequest({
      method: 'get_bucket',
      kwargs: {
        id: bucket.id,
      }
    }, function(new_bucket) {
      Store.updateBucket(new_bucket);
    })
  },
  render: function() {
    var balance_total = 0;
    var deposit_total = 0;
    var bucket_rows = this.props.buckets.map(function(bucket) {
      balance_total += bucket.balance;
      var computed = computeBucketDeposit(bucket);
      bucket.end_date = bucket.end_date || computed.end_date;
      bucket.goal = bucket.goal || computed.goal;
      bucket.deposit = bucket.deposit || computed.deposit;

      deposit_total += bucket.deposit;
      return (
        <BucketRow key={bucket.id} bucket={bucket} onPendingChange={this.pendingChanged} onBucketDirty={this.bucketIsDirty}></BucketRow>
      );
    }.bind(this));
    var pending_total = _.sum(_.values(this.state.pendings));
    return (
      <table className="ledger" width="100%">
        <thead>
          <tr>
            <th></th>
            <th>Bucket</th>
            <th className="right">Balance</th>
            <th className="right">Deposit</th>
            <th className="right">Monthly<br/>Deposit</th>
            <th>Goal</th>
            <th>Edit</th>
          </tr>
        </thead>
        <tbody>
          {bucket_rows}
        </tbody>
        <tbody>
          <tr className="subtotal">
            <td></td>
            <td>Total</td>
            <td className="right"><Money value={balance_total} /></td>
            <td className="right">
              <Money value={pending_total} />
            </td>
            <td className="right">
              <Money value={deposit_total} />
            </td>
            <td></td>
            <td></td>
          </tr>
        </tbody>
      </table>
    );
  }
});
Store.rerender();
</script>

<h2>Create bucket</h2>
<form method="post">
<div class="form">
  <div class="pair">
    <div class="label">Name</div>
    <div class="control"><input type="text" name="name"></div>
  </div>
  <div class="pair">
    <div class="label"></div>
    <div class="control"><button type="submit">Create Bucket</button></div>
  </div>
</div>
</form>

<h2>Create group</h2>
<form method="post" action="{{ url_for('.groups') }}">
<div class="form">
  <div class="pair">
    <div class="label">Name</div>
    <div class="control"><input type="text" name="name"></div>
  </div>
  <div class="pair">
    <div class="label"></div>
    <div class="control"><button type="submit">Create Group</button></div>
  </div>
</div>
</form>
{% endblock %}