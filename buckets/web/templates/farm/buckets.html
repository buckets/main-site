{% extends 'farm/base.html' %}

{% block content %}

<h1>Buckets</h1>

<script type="text/babel">
var target_el = thisNext();

var Store = {};
Store.groups = {{ groups|json|safe }};
Store.buckets = {{ buckets|json|safe }};
Store.rerender = function() {
  ReactDOM.render(<BucketTable buckets={Store.buckets} groups={Store.groups}/>, target_el);
}
Store.updateBucket = function(bucket) {
  _.each(Store.buckets, function(old_bucket) {
    if (old_bucket.id === bucket.id) {
      _.merge(old_bucket, bucket);
    }
  });
  Store.rerender();
}


var GroupRow = React.createClass({
  getInitialState: function() {
    return {
      underDrag: false,
      isDragging: false,
    }
  },
  pendingChanged: function() {
    // XXX
  },
  bucketIsDirty: function() {
    // XXX
  },

  // Dragging
  dragStart: function(ev) {
    ev.dataTransfer.setData('group', this.props.group.id);
    this.setState({isDragging: true});
  },
  dragEnd: function(ev) {
    this.setState({isDragging: false});
  },

  // Dropping
  drop: function(ev) {
    if (this.canAcceptDrop(ev)) {
      this.setState({underDrag: false});
      ev.preventDefault();
      _.each(ev.dataTransfer.items, function(item) {
        var data = ev.dataTransfer.getData(item.type);
        var method = 'acceptDrop_' + item.type;
        this[method](data);
      }.bind(this))
    }
  },
  dragOver: function(ev) {
    if (this.canAcceptDrop(ev)) {
      ev.preventDefault();
      this.setState({underDrag: true});
    }
  },
  dragLeave: function(ev) {
    if (this.canAcceptDrop(ev)) {
      ev.preventDefault();
      this.setState({underDrag: false});
    }
  },
  canAcceptDrop: function(ev) {
    if (this.props.group.id === 'NOGROUP') {
      return false;
    }
    return _.includes(ev.dataTransfer.types, 'bucket') ||
      _.includes(ev.dataTransfer.types, 'group');
  },
  acceptDrop_group: function(group_id) {
    console.log('accepting group', group_id);
  },
  acceptDrop_bucket: function(bucket_id) {
    console.log('accepting bucket', bucket_id);
  },

  render: function() {
    var bucket_rows = this.props.buckets.map(function(bucket) {
      return (
        <BucketRow key={bucket.id} bucket={bucket} onPendingChange={this.pendingChanged} onBucketDirty={this.bucketIsDirty}></BucketRow>
      );
    }.bind(this));
    var class_name = 'group';
    if (this.state.isDragging) {
      class_name += ' dragging';
    }
    if (this.state.underDrag) {
      class_name += ' underdrag';
    }
    var draggable = true;
    if (this.props.group.id == 'NOGROUP') {
      draggable = false;
    }
    return (
      <tbody>
        <tr className="group" className={class_name} draggable={draggable} onDragStart={this.dragStart} onDragEnd={this.dragEnd} onDragOver={this.dragOver} onDrop={this.drop} onDragLeave={this.dragLeave}>
          <td colSpan="2000">
            {this.props.group.name}
          </td>
        </tr>
        {bucket_rows}
      </tbody>
    );
  }
})

var BucketRow = React.createClass({
  getInitialState: function() {
    return {
      pending_amount: '',
      underDrag: false,
      isDragging: false,
    }
  },
  refreshBucket: function() {
    this.props.onBucketDirty(this.props.bucket);
  },
  pendingKeyUp: function(e) {
    if (e.keyCode === 13) {
      this.doTransaction();
    }
  },
  pendingChanged: function(value) {
    this.setPending(value);
  },
  setPending: function(value) {
    this.setState({
      pending_amount: value
    })
    this.props.onPendingChange(this.props.bucket, value);
  },
  doTransaction: function() {
    var amount = this.state.pending_amount;
    this.setPending('');
    apiRequest({
      method: 'bucket_transact',
      kwargs: {
        bucket_id: this.props.bucket.id,
        amount: amount,
      }
    }, function(response) {
      this.refreshBucket();
    }.bind(this));
  },

  // Dragging
  dragStart: function(ev) {
    ev.dataTransfer.setData('bucket', this.props.bucket.id);
    this.setState({isDragging: true});
  },
  dragEnd: function(ev) {
    this.setState({isDragging: false});
  },

  // Dropping
  drop: function(ev) {
    if (this.canAcceptDrop(ev)) {
      this.setState({underDrag: false});
      ev.preventDefault();
      _.each(ev.dataTransfer.items, function(item) {
        var data = ev.dataTransfer.getData(item.type);
        var method = 'acceptDrop_' + item.type;
        this[method](data);
      }.bind(this))
    }
  },
  dragOver: function(ev) {
    if (this.canAcceptDrop(ev)) {
      ev.preventDefault();
      this.setState({underDrag: true});
    }
  },
  dragLeave: function(ev) {
    if (this.canAcceptDrop(ev)) {
      ev.preventDefault();
      this.setState({underDrag: false});
    }
  },
  canAcceptDrop: function(ev) {
    return _.includes(ev.dataTransfer.types, 'bucket');
  },
  acceptDrop_bucket: function(bucket_id) {
    console.log('accepting bucket', bucket_id);
  },


  render: function() {
    var goal_bar;
    var class_name = '';
    if (this.state.isDragging) {
      class_name += ' dragging';
    }
    if (this.state.underDrag) {
      class_name += ' underdrag';
    }
    if (this.props.bucket.kind === 'goal') {
      goal_bar = (<GoalBar max={this.props.bucket.goal} value={this.props.bucket.balance} />);
    }
    return (
      <tr className={class_name} draggable="true" onDragStart={this.dragStart} onDragEnd={this.dragEnd} onDragOver={this.dragOver} onDrop={this.drop} onDragLeave={this.dragLeave}>
        <td>{this.props.bucket.name}</td>
        <td className="right"><Money value={this.props.bucket.balance} /></td>
        <td className="right">
          <MoneyInput className="right"
            value={this.state.pending_amount}
            onKeyUp={this.pendingKeyUp}
            onChange={this.pendingChanged}
            size="10" />
        </td>
        <td className="right"><Money value={this.props.bucket.deposit} /></td>
        <td>{goal_bar}</td>
        <td><a href={'buckets/'+this.props.bucket.id}>Edit</a></td>
      </tr>
    )
  }
});



var BucketTable = React.createClass({
  getInitialState: function() {
    return {
      pendings: {}
    }
  },
  pendingChanged: function(bucket, pending) {
    this.state.pendings[bucket.id] = pending;
    this.setState(this.state);
  },
  bucketIsDirty: function(bucket) {
    apiRequest({
      method: 'get_bucket',
      kwargs: {
        id: bucket.id,
      }
    }, function(new_bucket) {
      Store.updateBucket(new_bucket);
    })
  },
  render: function() {
    var group_buckets = {};
    var groups = [];
    _.each(this.props.buckets, function(bucket) {
      var group_id = bucket.group_id || 'NOGROUP';
      if (!group_buckets[group_id]) {
        group_buckets[group_id] = [];
      }
      group_buckets[group_id].push(bucket);
    })
    _.each(this.props.groups, function(group) {
      var buckets = group_buckets[group.id] || [];
      groups.push(<GroupRow key={group.id} group={group} buckets={buckets} />);
    });
    if (group_buckets['NOGROUP']) {
      var buckets = group_buckets['NOGROUP'];
      var group = {
        'id': 'NOGROUP',
        'name': 'Floaters',
        'rank': 'z',
      }
      groups.push(<GroupRow key={group.id} group={group} buckets={buckets} />);
    }
    /* var bucket_rows = this.props.buckets.map(function(bucket) {
      balance_total += bucket.balance;
      var computed = computeBucketDeposit(bucket);
      bucket.end_date = bucket.end_date || computed.end_date;
      bucket.goal = bucket.goal || computed.goal;
      bucket.deposit = bucket.deposit || computed.deposit;

      deposit_total += bucket.deposit;
      return (
        <BucketRow key={bucket.id} bucket={bucket} onPendingChange={this.pendingChanged} onBucketDirty={this.bucketIsDirty}></BucketRow>
      );
    }.bind(this)); */
    var pending_total = _.sum(_.values(this.state.pendings));
    var deposit_total = 0;
    var balance_total = 0;
    return (
      <table className="ledger" width="100%">
        <thead>
          <tr>
            <th>Bucket</th>
            <th className="right">Balance</th>
            <th className="right">Deposit</th>
            <th className="right">Monthly<br/>Deposit</th>
            <th>Goal</th>
            <th>Edit</th>
          </tr>
        </thead>
        {groups}
        <tbody>
          <tr className="subtotal">
            <td>Total</td>
            <td className="right"><Money value={balance_total} /></td>
            <td className="right">
              <Money value={pending_total} />
            </td>
            <td className="right">
              <Money value={deposit_total} />
            </td>
            <td></td>
            <td></td>
          </tr>
        </tbody>
      </table>
    );
  }
});
Store.rerender();
</script>

<h2>Create bucket</h2>
<form method="post">
<div class="form">
  <div class="pair">
    <div class="label">Name</div>
    <div class="control"><input type="text" name="name"></div>
  </div>
  <div class="pair">
    <div class="label"></div>
    <div class="control"><button type="submit">Create Bucket</button></div>
  </div>
</div>
</form>

<h2>Create group</h2>
<form method="post" action="{{ url_for('.groups') }}">
<div class="form">
  <div class="pair">
    <div class="label">Name</div>
    <div class="control"><input type="text" name="name"></div>
  </div>
  <div class="pair">
    <div class="label"></div>
    <div class="control"><button type="submit">Create Group</button></div>
  </div>
</div>
</form>
{% endblock %}